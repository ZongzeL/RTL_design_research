这个版本把FIFO调好了，用instr_arlen_cntr_in 和instr_arlen_cntr_out之间的间距差去和fifo的depth去比，来控制当前是不是要发read_req。
这个办法已经成功了。read_req如果成功发了，instr_arlen_cntr_in就加，否则就保持原地址
这个办法可以解决以下所有问题：
1. read mem，我们可以知道memory是看到了addr和read_req就能把地址对应的值推出来，但是这个推是需要2个cycle的latency的。所以为了不因为latency影响读速度（driver不能看见一个响应才换一个读地址），所以读地址要一直往前无脑的推。
2. 然而，无脑的推读地址是有代价的，就是memory的有效数据只会保持一个cycle，这就要求在这一个cycle里把这个有效数据保存下来。这就要用到fifo。AXI 的RVALID被挂在FIFO的empty上，只要fifo存下数据后，不empty，AXI上的master就在读它。
3. 然而，fifo的长度是有限制的，不可能无限的存。那么就产生了一个新的问题，假如AXI上的master读RREADY的速度比read mem的速度慢，就会导致fifo 会起full。fifo的full本来应该限制read mem部分的读read_req，假如fifo full了，就不能再起read_req了。但是，由于memory有latency，那么fifo的full是不能实时的因为多读了几个read mem而忠实反映full了。那就堵不住新来的数据了。
4. 那么，就只能废掉fifo的full了，用instr_arlen_cntr_in - instr_arlen_cntr_out < FIFO_LENGTH来决定是不是发了会把fifo写full了的那么多个read_req。注意，这不是在说一种可能性，而是当时确实会发出一个写full了的read_req。因为假如instr_arlen_cntr_in - instr_arlen_cntr_out >= FIFO_LENGTH了，说明此时我发出来的读指令已经会造成几个cycle的memory latency后fifo被写full，那么即使在这几个cycle的latency里面有了外面的AXI R操作把instr_arlen_cntr_out往前推，但是当前情况下我们不能去赌AXI上的R操作。因此决不能再发read_mem req了。
5. instr_arlen_cntr_in instr_arlen_cntr_out每次在收到AXI 的AR指令时都会reset成0，理论上说，如果这个mem wrap的design里面有一个巨大的buffer （256 * 32）bit，我就可以不用fifo来存了，用instr_arlen_cntr_in 当write 下标，instr_arlen_cntr_out当read下标。但是这太占面积。理论上说，只要fifo的length比memory的latency大一点点就够了，不用太大的fifo
